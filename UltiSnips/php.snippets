snippet php
<?php


endsnippet

snippet if
if (${1:/* condition */}) {
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet elif
elseif (${1:/* condition */}) {
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet else
else {
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet for
for ($${1:i} = ${2:0}; $$1 ${3:<} ${4:0}; $$1${4:${3/^(<)?.*$/(?1:++:--)/}}) {
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet each
foreach ($${1:array} as $${2:key} => $${3:value}) {
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet switch
switch (${1:true}) {
	case ${2:true}:
		${0:${VISUAL:\/\////}}
		break;

	default:
		//
		break;
}
endsnippet

snippet try
try {
	${0:${VISUAL:\/\////}}
} catch (${1:Exception} $e) {
	//
}
endsnippet

snippet func
function ${1:functionName}($2) {
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet pubf
public function ${1:methodName}($2)
{
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet pubsf
public static function ${1:methodName}($2)
{
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet prof
protected function ${1:methodName}($2)
{
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet prosf
protected static function ${1:methodName}($2)
{
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet prif
private function ${1:methodName}($2)
{
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet prisf
private static function ${1:methodName}($2)
{
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet _c
${1/(,\s*)?(?:\w+)?(?:\s+)?(?:\$(\w+)?)?/(?2:protected $$2;\\n    )/g}${1/^[^$]*(\$\w+)?.*$/(?1:\\n    )/}public function __construct($1)
{
	${1/(,\s*)?(?:\w+)?(?:\s+)?(?:\$(\w+)?)?/(?2:(?1:\\\\n        )$this->$2 = $$2;)/g}${0:`!p snip.rv = "" if re.match(r"^[^$]*(\$\w+)?.*$", t[1]).group(1) else "//"`}
}
endsnippet

snippet class
namespace ${1:`!v substitute(substitute(expand('%:h'), '^.', '\u&', ''), '\/', '\\', 'g')`};

class ${2:`!v expand('%:t:r')`}
{
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet aclass
namespace ${1:`!v substitute(substitute(expand('%:h'), '^.', '\u&', ''), '\/', '\\', 'g')`};

abstract class ${2:`!v expand('%:t:r')`}
{
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet interface
namespace ${1:`!v substitute(substitute(expand('%:h'), '^.', '\u&', ''), '\/', '\\', 'g')`};

interface ${2:`!v expand('%:t:r')`}
{
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet trait
namespace ${1:`!v substitute(substitute(expand('%:h'), '^.', '\u&', ''), '\/', '\\', 'g')`};

trait ${2:`!v expand('%:t:r')`}
{
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet this
$this->${0:${VISUAL}}
endsnippet

snippet .
->${0:${VISUAL}}
endsnippet

snippet am
array_map(function (${1:$row}) {
	${0:${VISUAL:\/\////}}
}, ${2:$array});
endsnippet

snippet ia
in_array(${1:$needle}, ${2:$haystack})
endsnippet

snippet phpunit
namespace ${1:`!v substitute(substitute(expand('%:h'), '^.', '\u&', ''), '\/', '\\', 'g')`};

use Mockery as m;
use PHPUnit\Framework\TestCase;

class ${2:`!v expand('%:t:r')`} extends TestCase
{
	public function tearDown()
	{
		m::close();

		parent::tearDown();
	}

	public function test${2:TestName}()
	{
		${0:${VISUAL:\/\////}}
	}
}
endsnippet

snippet test
public function test${1:TestName}()
{
	${0:${VISUAL:\/\////}}
}
endsnippet

snippet ase
$this->assertEquals(${1:$expected}, ${2:$actual});
endsnippet

snippet asne
$this->assertNotEquals(${1:$expected}, ${2:$actual});
endsnippet

snippet ast
$this->assertTrue(${1:$actual});
endsnippet

snippet asf
$this->assertFalse(${1:$actual});
endsnippet

snippet asn
$this->assertNull(${1:$actual});
endsnippet

snippet asnn
$this->assertNotNull(${1:$actual});
endsnippet

snippet asi
	$this->assertInstanceOf(${1:Expected}::class, ${2:$actual});
endsnippet

snippet ast
	$this->assertInternalType(${1:'string'}, ${2:actual});
endsnippet

snippet asc
	$this->assertCount(${1:$expected}, ${2:$haystack});
endsnippet

snippet asnc
	$this->assertNotCount(${1:$expected}, ${2:$haystack});
endsnippet

snippet asco
	$this->assertContains(${1:$needle}, ${2:$haystack});
endsnippet

snippet asnco
	$this->assertNotContains(${1:$needle}, ${2:$haystack});
endsnippet

snippet ashk
	$this->assertArrayHasKey(${1:$key}, ${2:$haystack});
endsnippet

snippet asnhk
	this->assertArrayNotHasKey(${1:$key}, ${2:$haystack});
endsnippet
